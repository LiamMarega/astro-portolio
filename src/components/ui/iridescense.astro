---
interface Props {
    color?: [number, number, number];
    speed?: number;
    amplitude?: number;
    mouseReact?: boolean;
    class?: string;
    [key: string]: any;
}

const {
    color = [1, 0.5, 1],
    speed = 1.0,
    amplitude = 0.1,
    mouseReact = true,
    class: className,
    ...rest
} = Astro.props;
---

<div
    class:list={[
        "iridescence-wrapper relative w-full h-full overflow-hidden",
        className,
    ]}
    {...rest}
>
    <div
        data-iridescence
        data-color={JSON.stringify(color)}
        data-speed={speed}
        data-amplitude={amplitude}
        data-mouse-react={mouseReact}
        class="iridescence-canvas-container absolute inset-0 z-0"
    >
    </div>
    <div
        class="iridescence-content relative z-10 w-full h-full pointer-events-none"
    >
        <div class="w-full h-full pointer-events-auto">
            <slot />
        </div>
    </div>
</div>

<style>
    .iridescence-canvas-container :global(canvas) {
        display: block;
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
    }
</style>

<script>
    import { Renderer, Program, Mesh, Color, Triangle } from "ogl";

    const vertexShader = `
    attribute vec2 uv;
    attribute vec2 position;

    varying vec2 vUv;

    void main() {
      vUv = uv;
      gl_Position = vec4(position, 0, 1);
    }
  `;

    const fragmentShader = `
    precision highp float;

    uniform float uTime;
    uniform vec3 uColor;
    uniform vec3 uResolution;
    uniform vec2 uMouse;
    uniform float uAmplitude;
    uniform float uSpeed;

    varying vec2 vUv;

    void main() {
      float mr = min(uResolution.x, uResolution.y);
      vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;

      uv += (uMouse - vec2(0.5)) * uAmplitude;

      float d = -uTime * 0.5 * uSpeed;
      float a = 0.0;
      for (float i = 0.0; i < 8.0; ++i) {
        a += cos(i - d - a * uv.x);
        d += sin(uv.y * i + a);
      }
      d += uTime * 0.5 * uSpeed;
      vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);
      col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;
      gl_FragColor = vec4(col, 1.0);
    }
  `;

    class IridescenceEffect {
        container: HTMLElement;
        renderer: Renderer;
        gl: any;
        program: Program | null = null;
        mousePos = { x: 0.5, y: 0.5 };
        animateId: number = 0;
        mouseReact: boolean;
        color: [number, number, number];
        speed: number;
        amplitude: number;

        constructor(el: HTMLElement) {
            this.container = el;
            this.color = JSON.parse(el.dataset.color || "[1,1,1]");
            this.speed = parseFloat(el.dataset.speed || "1.0");
            this.amplitude = parseFloat(el.dataset.amplitude || "0.1");
            this.mouseReact = el.dataset.mouseReact === "true";

            this.renderer = new Renderer();
            this.gl = this.renderer.gl;
            this.gl.clearColor(1, 1, 1, 1);

            this.init();
        }

        init() {
            const { gl, container } = this;

            const resize = () => {
                const scale = 1;
                this.renderer.setSize(
                    container.offsetWidth * scale,
                    container.offsetHeight * scale,
                );
                if (this.program) {
                    this.program.uniforms.uResolution.value = new Color(
                        gl.canvas.width,
                        gl.canvas.height,
                        gl.canvas.width / gl.canvas.height,
                    );
                }
            };

            window.addEventListener("resize", resize, false);
            resize();

            const geometry = new Triangle(gl);
            this.program = new Program(gl, {
                vertex: vertexShader,
                fragment: fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new Color(...this.color) },
                    uResolution: {
                        value: new Color(
                            gl.canvas.width,
                            gl.canvas.height,
                            gl.canvas.width / gl.canvas.height,
                        ),
                    },
                    uMouse: {
                        value: new Float32Array([
                            this.mousePos.x,
                            this.mousePos.y,
                        ]),
                    },
                    uAmplitude: { value: this.amplitude },
                    uSpeed: { value: this.speed },
                },
            });

            const mesh = new Mesh(gl, { geometry, program: this.program });

            const update = (t: number) => {
                this.animateId = requestAnimationFrame(update);
                if (this.program) {
                    this.program.uniforms.uTime.value = t * 0.001;
                }
                this.renderer.render({ scene: mesh });
            };
            this.animateId = requestAnimationFrame(update);
            container.appendChild(gl.canvas);

            const handleMouseMove = (e: MouseEvent) => {
                const rect = container.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = 1.0 - (e.clientY - rect.top) / rect.height;
                this.mousePos = { x, y };
                if (this.program) {
                    this.program.uniforms.uMouse.value[0] = x;
                    this.program.uniforms.uMouse.value[1] = y;
                }
            };

            if (this.mouseReact) {
                const eventTarget = container.parentElement?.classList.contains(
                    "iridescence-wrapper",
                )
                    ? container.parentElement
                    : container;
                eventTarget.addEventListener(
                    "mousemove",
                    handleMouseMove as any,
                );
            }

            // Intersection Observer to stop/start animation when not visible (optimization)
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        if (!this.animateId)
                            this.animateId = requestAnimationFrame(update);
                    } else {
                        cancelAnimationFrame(this.animateId);
                        this.animateId = 0;
                    }
                });
            });
            observer.observe(container);
        }
    }

    // Initialize all instances
    const containers = document.querySelectorAll("[data-iridescence]");
    containers.forEach((container) => {
        new IridescenceEffect(container as HTMLElement);
    });
</script>
