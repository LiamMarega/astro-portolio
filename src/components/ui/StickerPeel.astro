---
interface StickerPeelProps {
    imageSrc: string;
    rotate?: number;
    peelBackHoverPct?: number;
    peelBackActivePct?: number;
    peelEasing?: string;
    peelHoverEasing?: string;
    width?: number | string;
    shadowIntensity?: number;
    lightingIntensity?: number;
    initialPosition?: "center" | "random" | { x: number; y: number };
    peelDirection?: number;
    class?: string;
    delay?: number;
}

const {
    imageSrc,
    rotate = 30,
    peelBackHoverPct = 30,
    peelBackActivePct = 40,
    peelEasing = "power3.out",
    peelHoverEasing = "power2.out",
    width = 200,
    shadowIntensity = 0.6,
    lightingIntensity = 0.1,
    initialPosition = "center",
    peelDirection = 0,
    class: className = "",
    delay = 0,
} = Astro.props as StickerPeelProps;

const defaultPadding = 12;

// Generate a unique ID to avoid filter collisions when using multiple instances
const uid = Math.random().toString(36).substring(2, 9);
const pointLightId = `pointLight-${uid}`;
const pointLightFlippedId = `pointLightFlipped-${uid}`;
const dropShadowId = `dropShadow-${uid}`;
const expandAndFillId = `expandAndFill-${uid}`;

const cssVars = {
    "--sticker-rotate": `${rotate}deg`,
    "--sticker-p": `${defaultPadding}px`,
    "--sticker-peelback-hover": `${peelBackHoverPct}%`,
    "--sticker-peelback-active": `${peelBackActivePct}%`,
    "--sticker-peel-easing": peelEasing,
    "--sticker-peel-hover-easing": peelHoverEasing,
    "--sticker-width-desktop": typeof width === "number" ? `${width}px` : width,
    "--sticker-width-mobile":
        typeof width === "number" ? `${width * 0.4}px` : `calc(${width} * 0.4)`,
    "--sticker-shadow-opacity": shadowIntensity.toString(),
    "--sticker-lighting-constant": lightingIntensity.toString(),
    "--peel-direction": `${peelDirection}deg`,
    "--sticker-start": `calc(-1 * ${defaultPadding}px)`,
    "--sticker-end": `calc(100% + ${defaultPadding}px)`,
};

const styleString = Object.entries(cssVars)
    .map(([k, v]) => `${k}:${v}`)
    .join(";");
---

<div
    class={`sticker-drag-target absolute cursor-grab active:cursor-grabbing transform-gpu opacity-0 ${className}`}
    style={styleString}
    data-initial-position={JSON.stringify(initialPosition)}
    data-peel-direction={peelDirection}
    data-delay={delay}
    id={`sticker-${uid}`}
>
    <svg width="0" height="0" class="absolute pointer-events-none">
        <defs>
            <filter id={pointLightId}>
                <feGaussianBlur stdDeviation="1" result="blur"></feGaussianBlur>
                <feSpecularLighting
                    result="spec"
                    in="blur"
                    specularExponent="100"
                    specularConstant={lightingIntensity}
                    lighting-color="white"
                >
                    <fePointLight class="point-light-el" x="100" y="100" z="300"
                    ></fePointLight>
                </feSpecularLighting>
                <feComposite in="spec" in2="SourceGraphic" result="lit"
                ></feComposite>
                <feComposite in="lit" in2="SourceAlpha" operator="in"
                ></feComposite>
            </filter>

            <filter id={pointLightFlippedId}>
                <feGaussianBlur stdDeviation="10" result="blur"
                ></feGaussianBlur>
                <feSpecularLighting
                    result="spec"
                    in="blur"
                    specularExponent="100"
                    specularConstant={lightingIntensity * 7}
                    lighting-color="white"
                >
                    <fePointLight
                        class="point-light-flipped-el"
                        x="100"
                        y="100"
                        z="300"></fePointLight>
                </feSpecularLighting>
                <feComposite in="spec" in2="SourceGraphic" result="lit"
                ></feComposite>
                <feComposite in="lit" in2="SourceAlpha" operator="in"
                ></feComposite>
            </filter>

            <filter id={dropShadowId}>
                <feDropShadow
                    dx="2"
                    dy="4"
                    stdDeviation={3 * shadowIntensity}
                    flood-color="black"
                    flood-opacity={shadowIntensity}></feDropShadow>
            </filter>

            <filter id={expandAndFillId}>
                <feOffset dx="0" dy="0" in="SourceAlpha" result="shape"
                ></feOffset>
                <feFlood flood-color="rgb(179,179,179)" result="flood"
                ></feFlood>
                <feComposite operator="in" in="flood" in2="shape"></feComposite>
            </filter>
        </defs>
    </svg>

    <div
        class="sticker-container relative select-none touch-none sm:touch-auto"
        style={`transform: rotate(${peelDirection}deg); transform-origin: center; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;`}
    >
        <div
            class="sticker-main"
            style={`filter: url(#${dropShadowId}); clip-path: polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-end), var(--sticker-start) var(--sticker-end)); transition: clip-path 0.6s ease-out;`}
        >
            <div style={`filter: url(#${pointLightId});`}>
                <img
                    src={imageSrc}
                    alt=""
                    class="block"
                    style={`transform: rotate(calc(${rotate}deg - ${peelDirection}deg)); width: var(--sticker-width);`}
                    draggable="false"
                />
            </div>
        </div>

        <!-- Shadow layer -->
        <div
            class="absolute top-4 left-2 w-full h-full opacity-40 pointer-events-none"
            style="filter: brightness(0) blur(8px);"
        >
            <div
                class="sticker-flap"
                style={`clip-path: polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-start) var(--sticker-start)); top: calc(-100% - var(--sticker-p) - var(--sticker-p)); transform: scaleY(-1); transition: all 0.6s ease-out;`}
            >
                <img
                    src={imageSrc}
                    alt=""
                    class="block"
                    style={`transform: rotate(calc(${rotate}deg - ${peelDirection}deg)); width: var(--sticker-width); filter: url(#${expandAndFillId});`}
                    draggable="false"
                />
            </div>
        </div>

        <!-- Flap layer -->
        <div
            class="sticker-flap absolute w-full h-full left-0"
            style={`clip-path: polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-start) var(--sticker-start)); top: calc(-100% - var(--sticker-p) - var(--sticker-p)); transform: scaleY(-1); transition: all 0.6s ease-out;`}
        >
            <div style={`filter: url(#${pointLightFlippedId});`}>
                <img
                    src={imageSrc}
                    alt=""
                    class="block"
                    style={`transform: rotate(calc(${rotate}deg - ${peelDirection}deg)); width: var(--sticker-width); filter: url(#${expandAndFillId});`}
                    draggable="false"
                />
            </div>
        </div>
    </div>
</div>

<style>
    .sticker-drag-target {
        will-change: transform;
        --sticker-width: var(--sticker-width-mobile);
    }

    @media (min-width: 640px) {
        .sticker-drag-target {
            --sticker-width: var(--sticker-width-desktop);
        }
    }

    .sticker-main,
    .sticker-flap {
        will-change: clip-path, transform, top;
    }

    /* Interaction effects using CSS variables */
    .sticker-container:hover .sticker-main,
    .sticker-container.touch-active .sticker-main {
        clip-path: polygon(
            var(--sticker-start) var(--sticker-peelback-hover),
            var(--sticker-end) var(--sticker-peelback-hover),
            var(--sticker-end) var(--sticker-end),
            var(--sticker-start) var(--sticker-end)
        ) !important;
    }

    .sticker-container:hover .sticker-flap,
    .sticker-container.touch-active .sticker-flap {
        clip-path: polygon(
            var(--sticker-start) var(--sticker-start),
            var(--sticker-end) var(--sticker-start),
            var(--sticker-end) var(--sticker-peelback-hover),
            var(--sticker-start) var(--sticker-peelback-hover)
        ) !important;
        top: calc(-100% + 2 * var(--sticker-peelback-hover) - 1px) !important;
    }

    .sticker-container:active .sticker-main {
        clip-path: polygon(
            var(--sticker-start) var(--sticker-peelback-active),
            var(--sticker-end) var(--sticker-peelback-active),
            var(--sticker-end) var(--sticker-end),
            var(--sticker-start) var(--sticker-end)
        ) !important;
    }

    .sticker-container:active .sticker-flap {
        clip-path: polygon(
            var(--sticker-start) var(--sticker-start),
            var(--sticker-end) var(--sticker-start),
            var(--sticker-end) var(--sticker-peelback-active),
            var(--sticker-start) var(--sticker-peelback-active)
        ) !important;
        top: calc(-100% + 2 * var(--sticker-peelback-active) - 1px) !important;
    }
</style>

<script>
    import { gsap } from "gsap";
    import { Draggable } from "gsap/Draggable";

    gsap.registerPlugin(Draggable);

    function initSticker(target: HTMLElement) {
        const container = target.querySelector(
            ".sticker-container",
        ) as HTMLElement;
        const pointLight = target.querySelector(
            ".point-light-el",
        ) as SVGElement;
        const pointLightFlipped = target.querySelector(
            ".point-light-flipped-el",
        ) as SVGElement;

        const initialPosition = JSON.parse(
            target.dataset.initialPosition || '"center"',
        );
        const peelDirection = parseFloat(target.dataset.peelDirection || "0");
        const delay = parseFloat(target.dataset.delay || "0");

        // Handle initial positioning
        if (initialPosition !== "center") {
            let startX = 0,
                startY = 0;
            if (
                typeof initialPosition === "object" &&
                initialPosition.x !== undefined
            ) {
                startX = initialPosition.x;
                startY = initialPosition.y;
            } else if (initialPosition === "random") {
                const parent = target.parentElement;
                if (parent) {
                    startX =
                        Math.random() *
                        (parent.clientWidth - target.clientWidth);
                    startY =
                        Math.random() *
                        (parent.clientHeight - target.clientHeight);
                }
            }
            gsap.set(target, { x: startX, y: startY });
        }

        // Appearance animation
        gsap.to(target, {
            opacity: 1,
            zIndex: 100, // Explicitly set z-index to be sure
            duration: 0.8,
            delay: delay,
            ease: "power2.out",
        });

        // Initialize Draggable behavior
        const draggable = Draggable.create(target, {
            type: "x,y",
            bounds: target.parentElement || undefined,
            inertia: true,
            onDrag(this: Draggable) {
                const rot = gsap.utils.clamp(-24, 24, this.deltaX * 0.4);
                gsap.to(target, {
                    rotation: rot,
                    duration: 0.15,
                    ease: "power1.out",
                });
            },
            onDragEnd() {
                gsap.to(target, {
                    rotation: 0,
                    duration: 0.8,
                    ease: "power2.out",
                });
            },
        })[0];

        // Maintain bounds on resize
        const handleResize = () => {
            draggable.update();
            const currentX = gsap.getProperty(target, "x") as number;
            const currentY = gsap.getProperty(target, "y") as number;
            const boundsEl = target.parentElement;
            if (!boundsEl) return;

            const boundsRect = boundsEl.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            const maxX = boundsRect.width - targetRect.width;
            const maxY = boundsRect.height - targetRect.height;

            const newX = Math.max(0, Math.min(currentX, maxX));
            const newY = Math.max(0, Math.min(currentY, maxY));

            if (newX !== currentX || newY !== currentY) {
                gsap.to(target, {
                    x: newX,
                    y: newY,
                    duration: 0.3,
                    ease: "power2.out",
                });
            }
        };

        window.addEventListener("resize", handleResize);
        window.addEventListener("orientationchange", handleResize);

        // Interactive lighting logic
        const updateLight = (e: MouseEvent) => {
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (pointLight) {
                gsap.set(pointLight, { attr: { x, y } });
            }

            const normalizedAngle = Math.abs(peelDirection % 360);
            if (pointLightFlipped) {
                if (normalizedAngle !== 180) {
                    gsap.set(pointLightFlipped, {
                        attr: { x, y: rect.height - y },
                    });
                } else {
                    gsap.set(pointLightFlipped, {
                        attr: { x: -1000, y: -1000 },
                    });
                }
            }
        };

        container.addEventListener("mousemove", updateLight);

        // Mobile touch state management
        container.addEventListener(
            "touchstart",
            () => container.classList.add("touch-active"),
            { passive: true },
        );
        container.addEventListener(
            "touchend",
            () => container.classList.remove("touch-active"),
            { passive: true },
        );
        container.addEventListener(
            "touchcancel",
            () => container.classList.remove("touch-active"),
            { passive: true },
        );
    }

    // Auto-initialize all sticker components found in the DOM
    document.querySelectorAll(".sticker-drag-target").forEach((el) => {
        initSticker(el as HTMLElement);
    });
</script>
