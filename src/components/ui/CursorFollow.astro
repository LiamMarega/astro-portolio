---

---

<div class='circle' aria-hidden="true" role="presentation" tabindex="-1"></div>

<style>
  .circle {
    --circle-size: 32px;
    position: fixed;
    height: var(--circle-size);
    width: var(--circle-size);
    border: 1px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
    top: calc(var(--circle-size) / 2 * -1);
    left: calc(var(--circle-size) / 2 * -1);
    pointer-events: none;
    z-index: 999;
    will-change: transform;
    backdrop-filter: blur(1px);
  }

  /* Hide on touch devices and small screens */
  @media (max-width: 768px), (hover: none) {
    .circle {
      display: none;
    }
  }

  /* Larger cursor for bigger screens */
  @media (min-width: 1200px) {
    .circle {
      --circle-size: 40px;
    }
  }

  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .circle {
      display: none;
      will-change: auto;
      transition: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .circle {
      border-color: currentColor;
      box-shadow: 0 0 8px currentColor;
    }
  }

  /* Focus indicator for keyboard navigation */
  .circle:focus-visible {
    outline: 2px solid #ffffff;
    outline-offset: 2px;
  }
</style>

<script>
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  // Select the circle element
  const circleElement = document.querySelector('.circle');
  
  // Exit early if reduced motion is preferred or element doesn't exist
  if (prefersReducedMotion || !circleElement) {
    if (circleElement) {
      (circleElement as HTMLElement).style.display = 'none';
    }
    // Exit script execution
    throw new Error('CursorFollow disabled due to accessibility preferences');
  }

  // Create objects to track mouse position and custom cursor position
  const mouse = { x: 0, y: 0 }; // Track current mouse position
  const previousMouse = { x: 0, y: 0 }; // Store the previous mouse position
  const circle = { x: 0, y: 0 }; // Track the circle position

  // Initialize variables to track scaling and rotation
  let currentScale = 0; // Track current scale value
  let currentAngle = 0; // Track current angle value

  // Update mouse position on the 'mousemove' event
  window.addEventListener('mousemove', (e) => {
    mouse.x = e.x;
    mouse.y = e.y;
  });
  
  // Handle keyboard navigation
  window.addEventListener('keydown', (e) => {
    // Hide cursor on Tab navigation for better accessibility
    if (e.key === 'Tab') {
      (circleElement as HTMLElement).style.opacity = '0.3';
    }
  });
  
  // Show cursor again on mouse movement
  window.addEventListener('mousemove', () => {
    (circleElement as HTMLElement).style.opacity = '1';
  }, { once: false });

  // Smoothing factor for cursor movement speed (0 = smoother, 1 = instant)
  const speed = 0.17;

  // Start animation
  const tick = () => {
    // MOVE
    // Calculate circle movement based on mouse position and smoothing
    circle.x += (mouse.x - circle.x) * speed;
    circle.y += (mouse.y - circle.y) * speed;
    // Create a transformation string for cursor translation
    const translateTransform = `translate(${circle.x}px, ${circle.y}px)`;

    // SQUEEZE
    // 1. Calculate the change in mouse position (deltaMouse)
    const deltaMouseX = mouse.x - previousMouse.x;
    const deltaMouseY = mouse.y - previousMouse.y;
    // Update previous mouse position for the next frame
    previousMouse.x = mouse.x;
    previousMouse.y = mouse.y;
    // 2. Calculate mouse velocity using Pythagorean theorem and adjust speed
    const mouseVelocity = Math.min(Math.sqrt(deltaMouseX ** 2 + deltaMouseY ** 2) * 4, 150);
    // 3. Convert mouse velocity to a value in the range [0, 0.5]
    const scaleValue = (mouseVelocity / 150) * 0.5;
    // 4. Smoothly update the current scale
    currentScale += (scaleValue - currentScale) * speed;
    // 5. Create a transformation string for scaling
    const scaleTransform = `scale(${1 + currentScale}, ${1 - currentScale})`;

    // ROTATE
    // 1. Calculate the angle using the atan2 function
    const angle = (Math.atan2(deltaMouseY, deltaMouseX) * 180) / Math.PI;
    // 2. Check for a threshold to reduce shakiness at low mouse velocity
    if (mouseVelocity > 20) {
      currentAngle = angle;
    }
    // 3. Create a transformation string for rotation
    const rotateTransform = `rotate(${currentAngle}deg)`;

    // Apply all transformations to the circle element in a specific order: translate -> rotate -> scale
    (circleElement as HTMLElement).style.transform =
      `${translateTransform} ${rotateTransform} ${scaleTransform}`;

    // Request the next frame to continue the animation
    window.requestAnimationFrame(tick);
  };

  // Start the animation loop
  tick();
</script>
